rxnNorm <-#
function(data = NULL, res = NULL,#
	fac1 = NULL, fac2 = NULL, fac2cols = NULL,#
	freckles = FALSE, type = c("connect", "fitLine"),#
	method = c("sem", "iqr", "mad", "box", "sem95"),#
	table = NULL, xlab = NULL, ylab = NULL, title = NULL, ...) {#
#
# Function to compare categorical data by#
# plotting means etc in the same panel#
# Option to connect the dots or do a fit#
# Bryan Hanson, DePauw Univ, July 2010#
#
# Both fac1 and fac2 must be given: this is G x E!#
# fac2 must be a factor, but fac1 can be either factor or numeric#
# Everything related to a particular level of fac2 should be colored the same#
#
	require(ggplot2)#
	require(ChemoSpec) # on GitHub#
	require(plyr)#
	require(ggExtra)#
	#
	if (is.null(fac2cols)) stop("You need to supply fac2cols")#
	#
	# 1st, reduce the df and clean it of NAs#
	# otherwise there is trouble with the counts#
	# plus this keeps the ggplot2 object size down#
	#
	keep <- c(res, fac1, fac2)#
	data <- data[, keep]#
	data <- na.omit(data)#
#
	# Specify the data & aesthetics#
		#
	p <- ggplot(data, aes_string(x = fac1, y = res, color = fac2,#
		group = fac2))#
#
	# now add layers as requested#
#
	if (freckles) {#
		jit <- position_jitter(width = 0.05, height = 0.0)#
		p <- p + geom_jitter(position = jit, size = 1.0) #
		}#
	#
	if (method == "box") { # this doesn't work right#
		p <- p + geom_boxplot(width = 0.2)#
		if (type == "connect") {#
			p <- p + stat_summary(fun.y = "median", geom = "line")#
				}#
		}#
		#
	if (method == "sem") {#
		p <- p + stat_summary(fun.data = "seXy")#
		if (type == "connect") {#
			p <- p + stat_summary(fun.y = "mean", geom = "line")#
				}#
		}#
		#
	if (method == "sem95") {#
		p <- p + stat_summary(fun.data = "seXy95")#
		if (type == "connect") {#
			p <- p + stat_summary(fun.y = "mean", geom = "line")#
				}#
		}#
		#
	if (method == "mad") {#
		p <- p + stat_summary(fun.data = "seXyMad")#
		if (type == "connect") {#
			p <- p + stat_summary(fun.y = "median", geom = "line")#
				}#
		}#
		#
	if (method == "iqr") {#
		p <- p + stat_summary(fun.data = "seXyIqr")#
		if (type == "connect") {#
			p <- p + stat_summary(fun.y = "median", geom = "line")#
				}#
		}#
	#
	if (type == "fitLine") {#
		p <- p + geom_smooth(method = "lm", se = FALSE)#
		#
		}#
		#
	# now add the common decorations & modifications#
	#
	p <- p  + scale_colour_manual(name = "", values = fac2cols) +#
		opts(axis.text.x = theme_text(colour = "black"),#
		axis.text.y = theme_text(colour = "black"),#
		axis.ticks = theme_blank()) + opts(...)		#
	# now add labels and fix limits (modified from qplot)#
	#
    if (!is.null(title)) p <- p + opts(title = title)#
    if (!is.null(xlab)) p <- p + xlab(xlab)#
    if (!is.null(ylab)) p <- p + ylab(ylab)#
#    if (exists("xlim")) p <- p + xlim(xlim)#
#    if (exists("ylim")) p <- p + ylim(ylim)#
#
	# now add summary tables#
	# using a nice table feature from ggExtra#
#
	if (!is.null(table)) {#
		#
		if (type == "connect") {#
			counts <- count(data, vars = c(fac2, fac1))#
			colnames(counts) <- c(fac2, fac1, "count")#
#
			p <- p + annotate("table", table[1], table[2], table = counts,#
				theme = theme.list(show.box = TRUE, separator = "black",#
				gp = gpar(cex = table[3]),#
               	show.csep = TRUE, show.rsep = TRUE, show.colnames = TRUE,#
               	show.rownames = FALSE))#
			}#
#
		if (type == "fitLine") {#
			lvls <- levels(data[,fac2])#
			nl <- length(lvls)#
			m <- c()#
			b <- c()#
			r2 <- c()#
			for (i in 1:nl) {#
				dat <- subset(data, data[,fac2] == lvls[i])#
				mod <- lm(dat[,res] ~ dat[,fac1])#
				m[i] <- round(mod$coef[2], 2)#
				b [i]<- round(mod$coef[1], 2)#
				r2[i] <- round(cor(dat[,fac1], dat[,res])^2, 4)#
				#
				}#
				#
			mod.res <- data.frame(line = lvls, m = m, b = b, r2 = r2)#
				#
			p <- p + annotate("table", table[1], table[2], table = mod.res,#
				theme = theme.list(show.box = TRUE, separator = "black",#
				gp = gpar(cex = table[3]),#
               	show.csep = TRUE, show.rsep = TRUE, show.colnames = TRUE,#
               	show.rownames = FALSE))#
				#
			}#
		}	#
	invisible(p)#
	}
res = c(rnorm(10, 5, 1.5), rnorm(10, 8, 2), rnorm(10, 14, 2.0), rnorm(10, 10, 1.5), rnorm(10, 15, 2), rnorm(10, 12,2.5))#
fac1 <- c(rep("L", 20), rep("M", 20), rep("H", 20))#
fac1 <- factor(fac1, levels = c("L", "M", "H"))#
fac2 <- c(rep("WT", 10), rep("DOM", 10))#
fac2 <- rep(fac2, 3)#
fac2 <- as.factor(fac2)#
num1 <- c(rep(5, 20), rep(10, 20), rep(12, 20))#
junk <- rep(1,60) # to be thrown away later during data compression#
#
td <- data.frame(r = res, f1 = fac1, f2 = fac2, no1 = num1, junk)#
td[5, 3] <- NA # remove a few values here and there#
td[30, 2] <- NA#
td[37, 2] <- NA#
td[47, 1] <- NA#
td[18, 4] <- NA#
#
rm(fac1) # clean up workspace#
rm(fac2)#
rm(junk)#
rm(res)#
rm(num1)
tst <- rxnNorm(data = td, res = "r", fac1 = "no1", fac2 = "f2", fac2cols = c("red", "blue"), freckles = TRUE, method = "sem", table = c(7, 15, 0.75), title = "rxnNorm Demo: x axis numeric with lm", type = "fitLine"); print(tst); rm(tst)
tst <- rxnNorm(data = td, res = "r", fac1 = "no1", fac2 = "f2", fac2cols = c("red", "blue"), freckles = TRUE, method = "sem", table = c(7, 15, 0.75), title = "rxnNorm Demo: x axis numeric & connected", type = "connect"); print(tst); rm(tst)
tst <- rxnNorm(data = td, res = "r", fac1 = "f1", fac2 = "f2", fac2cols = c("red", "blue"), freckles = TRUE, method = "sem", table = c(1.2, 15, 0.75), title = "rxnNorm Demo: x axis categorical & connected", type = "connect"); print(tst); rm(tst)
makeSpec <-#
function(peak.list, x.range, plot = TRUE, curves = FALSE, ...) {#
#
# Function to generate sample spectra or chromatograms#
# Bryan Hanson, DePauw Univ, July 2010#
#
	# tailing is handled by making sd a function of x (time)#
	# tailing can be disabled entirely with tail = NA#
	# peak.list must contain area, mu, sd, tail#
	#
	pl <- peak.list#
	ns <- length(pl$mu) # ns = no. of spec#
	if (is.null(pl$tail)) pl$tail <- rep(NA, ns)#
	#
	# create x-data, initialize y-data#
	# y.mat will hold each spectrum separately#
	#
	x <- seq(from = x.range[1], to = x.range[2], length.out = 1000)#
	y.mat <- matrix(data = NA, nrow = ns, ncol = 1000)#
	#
	for (n in 1:ns) {#
		y.mat[n,] <- gaussCurve(x, pl$area[n], pl$mu[n], pl$sd[n], pl$tail[n])#
		}#
	rn <- list()#
	for (n in 1:ns) {#
		rn[n] <- paste("area", pl$coef[n], "mu", pl$mu[n], "sigma", pl$sd[n], "tail", pl$tail[n], sep = " ")#
		}#
	#
	dimnames(y.mat)[[1]] <- rn#
	y.sum <- colSums(y.mat)#
#
	if (plot) {#
		plot(x, y.sum, type = "l", lwd = 2, col = "black", xlim = x.range, ...)#
		if (curves) for (n in 1:ns) lines(x, y.mat[n,], lwd = 1.0, col = "blue")#
		}#
	#
	all <- rbind(x, y.sum, y.mat)#
	}
gaussCurve <-#
function(x, area, mu, sigma, tail) {#
	#
	# Function to generate Gaussian curves#
	# Bryan Hanson, DePauw Univ, July 2010#
	# This version handles tailing#
#
	m <- mu#
	if (is.na(tail)) s <- sigma#
	if (!is.na(tail)) s <- sigma*tail*x#
	numerator <- exp(-1.0 * ((x - m)^2)/(2*s^2))#
	denominator <- s*sqrt(2*pi)#
	y <- area*numerator/denominator#
	}
#
#
nmrSpectrum <- function(peaks, draw = TRUE, data.pts = FALSE, ...) {#
	#
# Function to draw a theoretical 1H NMR spectrum#
# Simple, 1st order coupling only#
# Bryan Hanson, DePauw Univ, Feb 2011#
#
# peaks must have columns named delta, mult, J, area, width#
# J should be expressed in ppm, not Hz#
# peaks contents are expanded and passed to makeSpec#
# makeSpec requires area, mu, sd, tail#
	#
	p <- peaks#
	area <- mu <- sd <- tail <- c()#
	#
	for (n in 1:nrow(p)) {#
		# Get coefficients for each part of multiplet#
		z <- p$mult[n] - 1#
		coef <- choose(z, 0:z) # a strange name!#
		#
		# Calc areas#
		a <- coef * p$area[n]/sum(coef)#
		#
		# Calc chemical shifts#
		no.pks <- length(coef)#
#		cat("no.pks = ", no.pks, "\n")#
		m <- jSeq(no.pks) #
		m <- p$J[n]*m#
		m <- m + p$delta[n]#
#		cat("m = ", m, "\n")#
#
		area <- c(area, a)#
		mu <- c(mu, m)#
		sd <- c(sd, rep(p$width[n], length(m)))#
		}#
#
	ans <- data.frame(area = area, mu = mu, sd = sd, tail = rep(NA, length(area)))#
#
	if (draw) {#
		all <- makeSpec(peak.list = ans,#
			xlab = "chemical shift, ppm", ylab = "", xaxp = c(0, 12, 10), ...)#
#		labs <- paste(p$area, "H", sep = " ")#
#		y.pos <- max(all[2,])#
#		x.pos <- p$delta#
#		grid.text(x = x.pos, y = y.pos, label = labs, just = "left", gp = gpar(col = "red"))#
		}#
	if ((data.pts) && (draw)) return(all) else ans#
	}#
	#
# Quick function to create sequences of a given length centered on zero#
#
jSeq <- function(length.out) {#
	if (length.out%%2 == 1) {#
		zs <- 0L#
		for (n in 1:10) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
#
	if (length.out%%2 == 0) {#
		zs <- c()#
		for (n in seq(0.5, 10.5, by = 1)) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
		#
	ans <- zs#
	}
?text
#
#
nmrSpectrum <- function(peaks, draw = TRUE, data.pts = FALSE, ...) {#
	#
# Function to draw a theoretical 1H NMR spectrum#
# Simple, 1st order coupling only#
# Bryan Hanson, DePauw Univ, Feb 2011#
#
# peaks must have columns named delta, mult, J, area, width#
# J should be expressed in ppm, not Hz#
# peaks contents are expanded and passed to makeSpec#
# makeSpec requires area, mu, sd, tail#
	#
	p <- peaks#
	area <- mu <- sd <- tail <- c()#
	#
	for (n in 1:nrow(p)) {#
		# Get coefficients for each part of multiplet#
		z <- p$mult[n] - 1#
		coef <- choose(z, 0:z) # a strange name!#
		#
		# Calc areas#
		a <- coef * p$area[n]/sum(coef)#
		#
		# Calc chemical shifts#
		no.pks <- length(coef)#
#		cat("no.pks = ", no.pks, "\n")#
		m <- jSeq(no.pks) #
		m <- p$J[n]*m#
		m <- m + p$delta[n]#
#		cat("m = ", m, "\n")#
#
		area <- c(area, a)#
		mu <- c(mu, m)#
		sd <- c(sd, rep(p$width[n], length(m)))#
		}#
#
	ans <- data.frame(area = area, mu = mu, sd = sd, tail = rep(NA, length(area)))#
#
	if (draw) {#
		all <- makeSpec(peak.list = ans,#
			xlab = "chemical shift, ppm", ylab = "", xaxp = c(0, 12, 10), ...)#
		labs <- paste(p$area, "H", sep = " ")#
		y.pos <- max(all[2,])#
		x.pos <- p$delta#
		text(x = x.pos, y = y.pos, labels = labs, col = "red")#
		}#
	if ((data.pts) && (draw)) return(all) else ans#
	}#
	#
# Quick function to create sequences of a given length centered on zero#
#
jSeq <- function(length.out) {#
	if (length.out%%2 == 1) {#
		zs <- 0L#
		for (n in 1:10) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
#
	if (length.out%%2 == 0) {#
		zs <- c()#
		for (n in seq(0.5, 10.5, by = 1)) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
		#
	ans <- zs#
	}
#
#
nmrSpectrum <- function(peaks, draw = TRUE, data.pts = FALSE, ...) {#
	#
# Function to draw a theoretical 1H NMR spectrum#
# Simple, 1st order coupling only#
# Bryan Hanson, DePauw Univ, Feb 2011#
#
# peaks must have columns named delta, mult, J, area, width#
# J should be expressed in ppm, not Hz#
# peaks contents are expanded and passed to makeSpec#
# makeSpec requires area, mu, sd, tail#
	#
	p <- peaks#
	area <- mu <- sd <- tail <- c()#
	#
	for (n in 1:nrow(p)) {#
		# Get coefficients for each part of multiplet#
		z <- p$mult[n] - 1#
		coef <- choose(z, 0:z) # a strange name!#
		#
		# Calc areas#
		a <- coef * p$area[n]/sum(coef)#
		#
		# Calc chemical shifts#
		no.pks <- length(coef)#
#		cat("no.pks = ", no.pks, "\n")#
		m <- jSeq(no.pks) #
		m <- p$J[n]*m#
		m <- m + p$delta[n]#
#		cat("m = ", m, "\n")#
#
		area <- c(area, a)#
		mu <- c(mu, m)#
		sd <- c(sd, rep(p$width[n], length(m)))#
		}#
#
	ans <- data.frame(area = area, mu = mu, sd = sd, tail = rep(NA, length(area)))#
#
	if (draw) {#
		all <- makeSpec(peak.list = ans,#
			xlab = "chemical shift, ppm", ylab = "", xaxp = c(0, 12, 10), ...)#
		labs <- paste(p$area, "H", sep = " ")#
		y.pos <- max(all[2,])#
		x.pos <- p$delta#
		text(x = x.pos, y = y.pos, labels = labs, col = "red", pos = 2, offset = 3)#
		}#
	if ((data.pts) && (draw)) return(all) else ans#
	}#
	#
# Quick function to create sequences of a given length centered on zero#
#
jSeq <- function(length.out) {#
	if (length.out%%2 == 1) {#
		zs <- 0L#
		for (n in 1:10) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
#
	if (length.out%%2 == 0) {#
		zs <- c()#
		for (n in seq(0.5, 10.5, by = 1)) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
		#
	ans <- zs#
	}
#
#
nmrSpectrum <- function(peaks, draw = TRUE, data.pts = FALSE, ...) {#
	#
# Function to draw a theoretical 1H NMR spectrum#
# Simple, 1st order coupling only#
# Bryan Hanson, DePauw Univ, Feb 2011#
#
# peaks must have columns named delta, mult, J, area, width#
# J should be expressed in ppm, not Hz#
# peaks contents are expanded and passed to makeSpec#
# makeSpec requires area, mu, sd, tail#
	#
	p <- peaks#
	area <- mu <- sd <- tail <- c()#
	#
	for (n in 1:nrow(p)) {#
		# Get coefficients for each part of multiplet#
		z <- p$mult[n] - 1#
		coef <- choose(z, 0:z) # a strange name!#
		#
		# Calc areas#
		a <- coef * p$area[n]/sum(coef)#
		#
		# Calc chemical shifts#
		no.pks <- length(coef)#
#		cat("no.pks = ", no.pks, "\n")#
		m <- jSeq(no.pks) #
		m <- p$J[n]*m#
		m <- m + p$delta[n]#
#		cat("m = ", m, "\n")#
#
		area <- c(area, a)#
		mu <- c(mu, m)#
		sd <- c(sd, rep(p$width[n], length(m)))#
		}#
#
	ans <- data.frame(area = area, mu = mu, sd = sd, tail = rep(NA, length(area)))#
#
	if (draw) {#
		all <- makeSpec(peak.list = ans,#
			xlab = "chemical shift, ppm", ylab = "", xaxp = c(0, 12, 10), ...)#
		labs <- paste(p$area, "H", sep = " ")#
		y.pos <- max(all[2,])#
		x.pos <- p$delta#
		text(x = x.pos, y = y.pos, labels = labs, col = "red", pos = 2, offset = 1)#
		}#
	if ((data.pts) && (draw)) return(all) else ans#
	}#
	#
# Quick function to create sequences of a given length centered on zero#
#
jSeq <- function(length.out) {#
	if (length.out%%2 == 1) {#
		zs <- 0L#
		for (n in 1:10) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
#
	if (length.out%%2 == 0) {#
		zs <- c()#
		for (n in seq(0.5, 10.5, by = 1)) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
		#
	ans <- zs#
	}
peaks1 <- data.frame(#
	delta = c(1.3, 3.9, 10.2),#
	mult = c(3, 4, 1),#
	J = c(0.1, 0.1, 0),#
	area = c(3, 2, 1),#
	width = c(0.01, 0.01, 0.1))#
	#
res <- nmrSpectrum(peaks1, x.range = c(10, 0))
peaks1 <- data.frame(#
	delta = c(1.3, 3.9, 10.2),#
	mult = c(3, 4, 1),#
	J = c(0.1, 0.1, 0),#
	area = c(3, 2, 1),#
	width = c(0.01, 0.01, 0.1))#
	#
res <- nmrSpectrum(peaks1, x.range = c(12, 0))
peaks2 <- data.frame(#
	delta = c(1.3, 4.1, 10.2),#
	mult = c(2, 7, 1),#
	J = c(0.2, 0.2, 0),#
	area = c(7, 1, 1),#
	width = c(0.01, 0.01, 0.1))#
	#
res <- nmrSpectrum(peaks2, x.range = c(12, 0))
?par
#
#
nmrSpectrum <- function(peaks, draw = TRUE, data.pts = FALSE, ...) {#
	#
# Function to draw a theoretical 1H NMR spectrum#
# Simple, 1st order coupling only#
# Bryan Hanson, DePauw Univ, Feb 2011#
#
# peaks must have columns named delta, mult, J, area, width#
# J should be expressed in ppm, not Hz#
# peaks contents are expanded and passed to makeSpec#
# makeSpec requires area, mu, sd, tail#
	#
	p <- peaks#
	area <- mu <- sd <- tail <- c()#
	#
	for (n in 1:nrow(p)) {#
		# Get coefficients for each part of multiplet#
		z <- p$mult[n] - 1#
		coef <- choose(z, 0:z) # a strange name!#
		#
		# Calc areas#
		a <- coef * p$area[n]/sum(coef)#
		#
		# Calc chemical shifts#
		no.pks <- length(coef)#
#		cat("no.pks = ", no.pks, "\n")#
		m <- jSeq(no.pks) #
		m <- p$J[n]*m#
		m <- m + p$delta[n]#
#		cat("m = ", m, "\n")#
#
		area <- c(area, a)#
		mu <- c(mu, m)#
		sd <- c(sd, rep(p$width[n], length(m)))#
		}#
#
	ans <- data.frame(area = area, mu = mu, sd = sd, tail = rep(NA, length(area)))#
#
	if (draw) {#
		all <- makeSpec(peak.list = ans,#
			xlab = "chemical shift, ppm", ylab = "", yaxp = c(range(all[2,]), 0), ...)#
		labs <- paste(p$area, "H", sep = " ")#
		y.pos <- max(all[2,])#
		x.pos <- p$delta#
		text(x = x.pos, y = y.pos, labels = labs, col = "red", pos = 2, offset = 1)#
		}#
	if ((data.pts) && (draw)) return(all) else ans#
	}#
	#
# Quick function to create sequences of a given length centered on zero#
#
jSeq <- function(length.out) {#
	if (length.out%%2 == 1) {#
		zs <- 0L#
		for (n in 1:10) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
#
	if (length.out%%2 == 0) {#
		zs <- c()#
		for (n in seq(0.5, 10.5, by = 1)) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
		#
	ans <- zs#
	}
#
#
nmrSpectrum <- function(peaks, draw = TRUE, data.pts = FALSE, ...) {#
	#
# Function to draw a theoretical 1H NMR spectrum#
# Simple, 1st order coupling only#
# Bryan Hanson, DePauw Univ, Feb 2011#
#
# peaks must have columns named delta, mult, J, area, width#
# J should be expressed in ppm, not Hz#
# peaks contents are expanded and passed to makeSpec#
# makeSpec requires area, mu, sd, tail#
	#
	p <- peaks#
	area <- mu <- sd <- tail <- c()#
	#
	for (n in 1:nrow(p)) {#
		# Get coefficients for each part of multiplet#
		z <- p$mult[n] - 1#
		coef <- choose(z, 0:z) # a strange name!#
		#
		# Calc areas#
		a <- coef * p$area[n]/sum(coef)#
		#
		# Calc chemical shifts#
		no.pks <- length(coef)#
#		cat("no.pks = ", no.pks, "\n")#
		m <- jSeq(no.pks) #
		m <- p$J[n]*m#
		m <- m + p$delta[n]#
#		cat("m = ", m, "\n")#
#
		area <- c(area, a)#
		mu <- c(mu, m)#
		sd <- c(sd, rep(p$width[n], length(m)))#
		}#
#
	ans <- data.frame(area = area, mu = mu, sd = sd, tail = rep(NA, length(area)))#
#
	if (draw) {#
		all <- makeSpec(peak.list = ans,#
			xlab = "chemical shift, ppm", ylab = "", ...)#
		labs <- paste(p$area, "H", sep = " ")#
		y.pos <- max(all[2,])#
		x.pos <- p$delta#
		text(x = x.pos, y = y.pos, labels = labs, col = "red", pos = 2, offset = 1)#
		}#
	if ((data.pts) && (draw)) return(all) else ans#
	}#
	#
# Quick function to create sequences of a given length centered on zero#
#
jSeq <- function(length.out) {#
	if (length.out%%2 == 1) {#
		zs <- 0L#
		for (n in 1:10) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
#
	if (length.out%%2 == 0) {#
		zs <- c()#
		for (n in seq(0.5, 10.5, by = 1)) {#
			if (length(zs) == length.out) break#
			zs <- c(-n, zs, n)#
			}#
		}#
		#
	ans <- zs#
	}
peaks3 <- data.frame(#
	delta = c(1.3, 3.5, 4.5, 9.1),#
	mult = c(2, 9, 2, 1),#
	J = c(0.2, 0.2, 0.2, 0),#
	area = c(7, 1, 2, 1),#
	width = c(0.01, 0.01, 0.01, 0.1))#
	#
res <- nmrSpectrum(peaks3, x.range = c(10, 0),#
	main = "1H NMR of iso-butanol")
cart <- expand.grid(#
	x = c(-1, 0, 1),#
	y = c(-1, 0, 1),#
	z = c(-1, 0, 1))
sink("coord.txt")
cart
sink()
?grid.xspline
library(sos)
findFn("spline spherical")
findFn("bernstein")
findFn("vincenty")
findFn("b-spline spherical")
findFn("b-spline 3d")
findFn("b-spline polar")
findFn("b-spline")
findFn("b-spline multivariate")
?xpline
xspline
findFn("b-spline draw")
?xspline
cart2sph <- function(df) { # seems to work properly#
	x <- df$x#
	y <- df$y#
	z <- df$z#
	radius <- sqrt(x^2 + y^2 + z^2)#
	if (any(radius == 0)) warning("One of these points is the origin")#
	phi <- acos(z/radius)*180/pi#
	theta <- atan2(y, x)*180/pi#
#	phi <- atan(y/x)*180/pi#
#	for (n in 1:length(phi)) if (phi[n] < 0) phi[n] <- phi[n] + 180#
	ans <- data.frame(radius, theta, phi) # answer in degrees#
	}#
#
sph2cart <- function(df) { # seems to work properly#
	r <- df$radius#
	theta <- df$theta#
	phi <- df$phi#
	theta <- theta * 2 * pi/360 # input angles in degrees#
	phi <- phi * 2 * pi/360#
	x <- r * cos(theta) * sin(phi)#
	y <- r * sin(theta) * sin(phi)#
	z <- r * cos(phi) #
	ans <- data.frame(x, y, z)#
	} # answer in degrees
	r <- c(0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1) # in polar coordinates#
	theta <- c(0, 0, 0, 90, 0, 180, 0, 270, 0, 0, 0, 0)  # start, end, start, end#
	phi <- c(0, 90, 0, 90, 0, 90, 0, 90, 0, 0, 0, 180)#
	cs <- data.frame(radius = r, theta, phi)#
	ax.coord <- sph2cart(cs)#
	#
	segments3d(ax.coord, col = "gray", line_antialias = TRUE)#
	points3d(x = 0, y = 0, z = 0, color = "black", size = 4,#
		point_antialias = TRUE) # plot origin#
	#
# Label the axes#
#
	r <- c(1.1, 1.1, 1.1, 1.1, 1.1, 1.1) # in polar coordinates#
	theta <- c(0, 90, 180, 270, 0, 0)  # start, end, start, end#
	phi <- c(90, 90, 90, 90, 0, 180)#
	l <- data.frame(radius = r, theta, phi)#
	lab.coord <- sph2cart(l)#
	text3d(lab.coord, texts = c("+x", "+y", "-x", "-y", "+z", "-z"))
rgl.snapshot("coord.png")
getwd()
findFn("spline surface")
?rotate3d
rotationMatrix(pi/2, 1, 0, 0)
rotate3d
getAnywhere(rotate3d)
rotate3d.default
default.rotate3d
library(geometry)
?extprod3d
